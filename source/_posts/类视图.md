---
title: 类视图
date: 2018-12-13 22:39:41
tags:
  - Django2.0
category: 学习笔记
---

类视图是 Django 官方推荐的一种写法，就使用类的方式构建视图，这样就可以利用类的属性继承等特点。
<!-- more -->

## View
类视图需要继承 django.views.generic.base.View 。然后可以根据当前的请求的 method，来实现不同的方法。类视图在做 url 映射时，需要调用 as_view()方法。
```
class BookDetailView(View):
    def get(self, request):
        return render(request, 'add_book.html')

    def post(self, request):
        print(request.POST.get('bookname'))
        print(request.POST.get('author'))
        return HttpResponse("提交成功")
```

不同是什么请求方式，类视图首先都是交给 dispatch(request, *args, **kwargs)来处理。
```
# dispatch方法的源码
def dispatch(self, request, *args, **kwargs):
    # Try to dispatch to the right method; if a method doesn't exist,
    # defer to the error handler. Also defer to the error handler if the
    # request method isn't on the approved list.
    if request.method.lower() in self.http_method_names:
        handler = getattr(self, request.method.lower(), self.http_method_not_allowed)
        else:
            handler = self.http_method_not_allowed
        return handler(request, *args, **kwargs)
```

如果访问了 View 中没有定义的方法。那么就会把这个请求转发给 http_method_not_allowed(request, *args, **kwargs) 方法。
```
def http_method_not_allowed(self, request, *args, **kwargs):
    logger.warning(
            'Method Not Allowed (%s): %s', request.method, request.path,
            extra={'status_code': 405, 'request': request}
        )
    return HttpResponseNotAllowed(self._allowed_methods())
```


## TemplateView:
django.views.generic.base.TemplateView 这个视图可以直接返回模板，常用属性
  + templaet_name: 指定模板的路径 
  + get_context_date: 用来返回上下文数据的，可以直接数据传入模板中。

```
class AboutView(TemplateView):
    template_name = 'about.html'
    
    def get_context_data(self, **kwargs):
        context = {'phone': '0571-8585334'}
        return context 
```

如果在模板不需要传递任何参数，完成返回的是一格静态页面，可以直接到 urls.py 中使用。
```
path('about/', TemplateView.as_view(template_name='about.html')),
```


## ListView:
 如果需要将某些数据作为列表展示出来，就可以是 ListView。
```
lass ArticleListView(ListView):
    model = Article
    template_name = 'article_list.html'
    context_object_name = 'articles'
    paginate_by = 10
    ordering = 'id'
    page_kwarg = 'page'

    def get_context_data(self, **kwargs):
        context = super(ArticleListView, self).get_context_data(**kwargs)
        context['username'] = 'threefire'
        print(context)
        return context

    def get_queryset(self):
        return Article.objects.filter(id__lte=5)
```

+ model: 指定给那个模型生成列表
+ tempalte_name: 指定关联的模板
+ context_objects_name: 传人模板中 context 的名字
+ paginate_by: 一页显示多少条数据
+ ordering: 根据那个字段排序
+ page_kwarg: 获取第几页数据的参数名
+ get_context_data: 获取上下文的数据
+ get_queryser: 指定返回字段

注意在 get_context_data 中要先调用父类的 get_context_data 避免重写这个方法导致一些参数不可用。

### Paginator和Page类
在 context 中还附带着这两个对象，这两个对象是做分页用的。
```
'paginator': <django.core.paginator.Paginator object at 0x00000000041EB208>, 'page_obj': <Page 10 of 10>,
```

#### Paginator常用属性和方法
  + count: 总共有多少条数据。
  + num_pages: 总共有多少页。
  + page_range: 页面的数字区间。如果有三页那么就range(1,4)
  
#### Page常用属性和方法
  + has_next: 是否还有下一页。
  + has_previous: 是否还有上一页。
  + next_page_number: 下一页的页码。
  + previous_page_number: 上一页的页码。
  + number: 当前页。
  + start_index: 当前这一页的第一条数据的索引值。
  + end_index: 当前这一页的最后一条数据的索引值。

利用Paginator和Page实现分页
```
<ul class="pagination">
    {# 上一页 #}
    {% if page_obj.has_previous %}
        <li><a href="{% url 'front:list' %}?page={{ articles.previous_page_number }}">上一页</a></li>
    {% else %}
        <li class="disabled"><a href="javascript:void(0)">上一页</a></li>
    {% endif %}

    {# 数字页 #}
    {% for pages in paginator.page_range %}
        {% if pages == page_obj.number %}
            <li class="active"><a href="javascript:void(0)">{{ pages }}</a></li>
        {% else %}
            <li><a href="{% url 'front:list' %}?page={{ pages}}">{{ pages }}</a></li>
         {% endif %}
    {% endfor %}
    
    {# 下一页 #}
    {% if page_obj.has_next %}
        <li><a href="{% url 'front:list' %}?page={{ page_obj.next_page_number }}">下一页</a></li>
    {% else %}
        <li class="disabled"><a href="javascript:void(0)">下一页</a></li>
    {% endif %}
</ul>
```

如果想要显示如下形式的分页。
```
# views.py (ListView)
    def get_pagination_data(self, paginator, page_obj, around_count=2):
        current_page = page_obj.number
        num_pages = paginator.num_pages

        left_has_more = False
        right_has_more = False

        if current_page <= around_count+2:
            left_pages = range(1, current_page)
        else:
            left_has_more = True
            left_pages = range(current_page-around_count, current_page)

        if current_page >= num_pages-around_count-1:
            right_pages = range(current_page+1, num_pages+1)
        else:
            right_has_more = True
            right_pages = range(current_page+1, current_page+around_count+1)

        return {
            'left_pages': left_pages,
            'right_pages': right_pages,
            'current_page': current_page,
            'left_has_more': left_has_more,
            'right_has_more': right_has_more,
            'num_pages': num_pages,
        }
```

```
# .html
{# 左边页 #}
       <li><a href="{% url 'front:list' %}?page=1">1</a></li>
       {% if left_has_more %}
           <li><a href="javascript:void(0)">...</a></li>
       {% endif %}
       {% for left_page in left_pages %}
           <li><a href="{% url 'front:list' %}?page={{ left_page }}">{{ left_page }}</a></li>
       {% endfor %}

       {# 当前页 #}
       <li><a href="{% url 'front:list' %}?page={{ current_page }}">{{ current_page }}</a></li>

      {# 右边页 #}
      {% for right_page in right_pages %}
          <li><a href="{% url 'front:list' %}?page={{ right_page }}">{{ right_page }}</a></li>
      {% endfor %}
      {% if right_has_more %}
          <li><a href="javascript:void(0)">...</a></li>
      {% endif %}
      <li><a href="{% url 'front:list' %}?page={{ num_pages }}">{{ num_pages }}</a></li>

```

## 给类视图添加装饰器
给函数视图添加装饰器，直接写上上就行，如果给类视图添加装饰器有两种方式实现。
### 装饰 dispatch 方法
因为在类视图中所有的请求方法进来都要先调用 dispatch 方法，所以可以对这个方法进行装饰。
```
from django.utils.decorators import method_decorator

def login_required(func):
    def wrapper(request,*args,**kwargs):
        if request.GET.get("username"):
            return func(request,*args,**kwargs)
        else:
            return redirect(reverse('index'))
    return wrapper


class IndexView(View):
    def get(self,request,*args,**kwargs):
        return HttpResponse("index")

    @method_decorator(login_required)
    def dispatch(self, request, *args, **kwargs):
        super(IndexView, self).dispatch(request,*args,**kwargs)
```

### 直接装饰在类上
添加一个 name 参数，指定要装饰的方法。
```
from django.utils.decorators import method_decorator
def login_required(func):
    def wrapper(request,*args,**kwargs):
        if request.GET.get("username"):
            return func(request,*args,**kwargs)
        else:
            return redirect(reverse('login'))
    return wrapper


@method_decorator(login_required,name='dispatch')
class IndexView(View):
    def get(self,request,*args,**kwargs):
        return HttpResponse("index")

    def dispatch(self, request, *args, **kwargs):
        super(IndexView, self).dispatch(request,*args,**kwargs)
```
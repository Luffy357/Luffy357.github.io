---
title: 权限和分组
date: 2019-01-08 22:14:53
tags:
  - Django2.0
category: 学习笔记
---

Django中内置了权限的功能。他的权限都是针对表或者说是模型级别的。比如对某个模型上的数据是否可以进行增删改查操作。他不能针对数据级别的，比如对某个表中的某条数据能否进行增删改查操作（如果要实现数据级别的，考虑使用 django-guardian。
<!-- more -->

## 登录注销和登录限制

### 登录
在使用 authenticate 进行验证后，如果验证通过了，那么返回一个 user 对象，拿到 user 对象后，可以使用 django.contrib.auth.login 进行登录。
```
def my_login(request):
    if request.method == 'GET':
        return render(request, 'login.html')
    if request.method == 'POST':
        forms = LoginForm(request.POST)
        if forms.is_valid():
            telephone = forms.cleaned_data.get('telephone')
            password = forms.cleaned_data.get('password')
            remember = forms.cleaned_data.get('remember')
            user = authenticate(request, username=telephone, password=password)
            if user and user.is_active:
                login(request, user)
                if remember:
                    request.session.set_expiry(None)
                else:
                    request.session.set_expiry(0)
                # 登录成功后跳转的页面
                next_url = request.GET.get('next')
                if next_url:
                    return redirect(next_url)
                else:
                    return HttpResponse('登录成功')
            else:
                return HttpResponse('手机号或者密码错误')
        else:
            print(forms.errors)
            return redirect(reverse('login'))

```

### 注销
注销，也就是退出登录，可以通过 django.contrib.auth.logout 来实现，其实就是清理这个用户的 session 数据。
```
def my_logout(request):
    logout(request)
    return HttpResponse('退出登录')

```

### 登录限制
有的视图是要进过登录后才能访问的，那么就可以通过 django.contrib.auth.decorators.login_required 装饰器来实现。
```
# 验证失败跳转到 login_url
@login_required(login_url='/login/')
def profile(request):
    return HttpResponse('个人中心')
```

## 权限
创建完一个模型后，针对这个模型默认就有三种权限，分别是增/删/改/。可以在执行完migrate 命令后，查看数据库中的 auth_permission 表中的所有权限， 其中字段 conent_type_id 表示这个权限所属那个 App 的， codename 表示权限的名字，name 表示的是这个权限的作用。

### 定义模型时添加权限
如果想在增加新的权限，那么可以在定义模型的时候在 Meta 中定义
```
class Meta:
    permissions = (
        ('view_article', '查看文章'))
```

### 通过代码添加权限
权限都是django.contrib.auth.Permission的实例。这个模型包含三个字段，name、codename以及content_type，其中的content_type表示这个permission是属于哪个app下的哪个models。用Permission模型创建权限的代码如下
```
from django.contrib.auth.models import Permission, ContentType
from .models imort Article

content_type = ContentType.objects.get_for_model(Article)
permission = Permission.objects.create(name='可以编辑的权限'， codename='edit_article', content_type=content_type)
```

### 用户与权限管理
权限本身只是一个数据，必须和用户进行绑定才能起作用，就像一个标牌。user 模型和权限直接的管理有以下几种
 + myuser.user_permissions.set(permission_list)：直接给定一个权限的列表。
 + myuser.user_permissions.add(permission,permission,...)：一个个添加权限。可以通过 *permission 同时传递多个数据
 + myuser.user_permissions.remove(permission,permission,...)：一个个删除权限。
 + myuser.user_permissions.clear()：清除权限。
 + myuser.has_perm('<app_name>.<codename>')：判断是否拥有某个权限。权限参数是一个字符串，格式是app_name.codename。
myuser.get_all_permissons()：获取所有的权限。
```
def operate_permission(request):
    user = User.objects.first()
    content_type = ContentType.objects.get_for_model(Article)
    permissions = Permission.objects.filter(content_type=content_type)
    for permission in permissions:
        print(permission)
    user.user_permissions.set(permissions)
    return HttpResponse('succeed')

```

### 权限限定装饰器
使用 django.contrib.auth.decorators.permission_required 可以非常方便的检查用户是否拥有这个权限，如果拥有，那么就可以进入到指定的视图函数中，如果不拥有，那么就会报一个400错误，
```
from django.contrib.auth.decorators import permission_required

@permission_required('front.view_article')
def my_view(request):
   .....
```
这个装饰器还有两个参数
 + login_url: 没有登录跳转的url地址
 + raise_exception：为 Ture 的话跳转到 django 中定义的错误页面
如果要判断多个权限，可以将第一个参数设为一个权限列表。

## 分组
权限有很多，一个模型就有最少三个权限，如果一些用户拥有相同的权限，那么每次都要重复添加。这时候分组就可以帮我们解决这种问题了，我们可以把一些权限归类，然后添加到某个分组中，之后再把和把需要赋予这些权限的用户添加到这个分组中，就比较好管理了。分组我们使用的是django.contrib.auth.models.Group模型， 每个用户组拥有id和name两个字段，该模型在数据库被映射为auth_group数据表。

### 分组操作
1、Group.object.create(group_name)：创建分组。
2、group.permissions：某个分组上的权限。多对多的关系。
 + group.permissions.add：添加权限。
 + group.permissions.remove：移除权限。
 + group.permissions.clear：清除所有权限。
3、user.get_group_permissions()：获取用户所属组的权限。
user.groups：某个用户上的所有分组。多对多的关系。
```
def operate_group(request):
    # 添加分组
    group = Group.objects.create(name='运营')
    content_type = ContentType.objects.get_for_model(Article)
    permissions = Permission.objects.filter(content_type=content_type)
    group.permissions.set(permissions)
    group.save()

    # 用户添加分组
    group = Group.objects.filter(name='运营').first()
    user = User.objects.first()
    user.groups.add(group)
    user.save()
```

### 在模板中使用去权限
在settings.TEMPLATES.OPTIONS.context_processors下，因为添加了django.contrib.auth.context_processors.auth上下文处理器，因此在模板中可以直接通过perms来获取用户的所有权限。示例代码如下
```
# 如果用户没有这个权限就不会显示里面的内容
{% if perms.front.add_article %}
    <a href='#'> 添加文章 </a>
{% endif %}
```